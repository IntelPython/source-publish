#!/bin/sh
#
# Copyright (C) 2015 Free Software Foundation, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#

progname=$0

# func_exit STATUS
# exits with a given status.
# This function needs to be used, rather than 'exit', when a 'trap' handler is
# in effect that refers to $?.
func_exit ()
{
  (exit $1); exit $1
}

# func_fatal_error message
# outputs to stderr a fatal error message, and terminates the program.
# Input:
# - progname                 name of this program
func_fatal_error ()
{
  echo "$progname: *** $1" 1>&2
  echo "$progname: *** Stop." 1>&2
  func_exit 1
}

# func_tmpdir
# creates a temporary directory.
# Input:
# - progname                 name of this program
# Sets variable
# - tmp             pathname of freshly created temporary directory
func_tmpdir ()
{
  # Use the environment variable TMPDIR, falling back to /tmp. This allows
  # users to specify a different temporary directory, for example, if their
  # /tmp is filled up or too small.
  : ${TMPDIR=/tmp}
  {
    # Use the mktemp program if available. If not available, hide the error
    # message.
    tmp=`(umask 077 && mktemp -d "$TMPDIR/glXXXXXX") 2>/dev/null` &&
    test -n "$tmp" && test -d "$tmp"
  } ||
  {
    # Use a simple mkdir command. It is guaranteed to fail if the directory
    # already exists.  $RANDOM is bash specific and expands to empty in shells
    # other than bash, ksh and zsh.  Its use does not increase security;
    # rather, it minimizes the probability of failure in a very cluttered /tmp
    # directory.
    tmp=$TMPDIR/gl$$-$RANDOM
    (umask 077 && mkdir "$tmp")
  } ||
  {
    echo "$progname: cannot create a temporary directory in $TMPDIR" >&2
    func_exit 1
  }
}

test -n "$GNULIB_SRCDIR" || \
    func_fatal_error "$progname: GNULIB_SRCDIR is not set"

test -n "$UCD" || \
    func_fatal_error "$progname: UCD is not set"

func_tmpdir
trap 'exit_status=$?
      if test "$signal" != 0; then
        echo "caught signal $signal" >&2
      fi
      rm -rf "$tmp"
      exit $exit_status' 0
for signal in 1 2 3 13 15; do
  trap '{ signal='$signal'; func_exit 1; }' $signal
done
signal=0

: ${CLISP=clisp}
("$CLISP" --version) >/dev/null 2>/dev/null \
  || { echo "$progname: *** clisp not found; skipping uniname" 1>&2; exit 0; }

sed -e '/^[0-9A-F]*;</d' "$UCD/UnicodeData.txt" > "$tmp/UnicodeDataNames.txt"

sed -e 's/ *$//' -e '/^#/d' -e '/^$/d' < "$UCD/NameAliases.txt" \
    > "$tmp/NameAliases.txt"

"$CLISP" "$GNULIB_SRCDIR/lib/uniname/gen-uninames.lisp" \
         "$tmp/UnicodeDataNames.txt" \
         "$GNULIB_SRCDIR/lib/uniname/uninames.h" \
         "$tmp/NameAliases.txt"

# Copy necessary files from UCD
for dstfile in "$GNULIB_SRCDIR/tests/uniname/UnicodeData.txt" \
             "$GNULIB_SRCDIR/tests/uniname/NameAliases.txt" ; do
  srcfile=`expr "$dstfile" : '.*/\(.*\)'`
  if test -f "$UCD/$srcfile"; then
    srcfile="$UCD/$srcfile"
  elif test -f "$UCD/auxiliary/$srcfile"; then
    srcfile="$UCD/auxiliary/$srcfile"
  else
    func_fatal_error "cannot find $srcfile"
  fi

  sed 's/ *$//' < "$srcfile" > "$dstfile"
done

rm -rf "$tmp"

# Undo the effect of the previous 'trap' command. Some shellology:
# We cannot use "trap - 0 1 2 3 13 15", because Solaris sh would attempt to
# execute the command "-". "trap '' ..." is fine only for signal 0 (= normal
# exit); for the others we need to call 'exit' explicitly. The value of $? is
# 128 + signal number and is set before the trap-registered command is run.
trap '' 0
trap 'func_exit $?' 1 2 3 13 15

exit 0
